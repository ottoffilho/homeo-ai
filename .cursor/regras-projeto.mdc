---
description: 
globs: 
alwaysApply: true
---
# üß† Regras Gerais do Projeto Homeo-AI

Sempre fale em portugu√™s.

## üéØ Objetivo
Desenvolver e manter o Homeo-AI como um sistema escal√°vel, modular, com c√≥digo limpo e de alta qualidade. Cada componente e funcionalidade deve ter um prop√≥sito claro, com documenta√ß√£o e coment√°rios que agreguem valor, facilitando a manuten√ß√£o, colabora√ß√£o e evolu√ß√£o do projeto.

## üìå Diretrizes T√©cnicas Fundamentais
- **Modularidade:** Divida funcionalidades complexas em m√≥dulos, fun√ß√µes e componentes menores, coesos e reutiliz√°veis.
- **Legibilidade:** Priorize c√≥digo claro e autoexplicativo. Utilize nomes de vari√°veis, fun√ß√µes e classes que descrevam seu prop√≥sito.
- **DRY (Don't Repeat Yourself):** Evite duplica√ß√£o de c√≥digo. Crie abstra√ß√µes e utilize componentes/fun√ß√µes reutiliz√°veis.
- **Simplicidade (KISS - Keep It Simple, Stupid):** Prefira solu√ß√µes diretas e simples sempre que poss√≠vel, evitando complexidade desnecess√°ria.
- **Escalabilidade:** Ao projetar novas funcionalidades ou refatorar existentes, considere o impacto no desempenho e na capacidade de crescimento do sistema.
- **Organiza√ß√£o:** Mantenha uma estrutura de pastas l√≥gica e consistente, seguindo as conven√ß√µes j√° estabelecidas no frontend (React/Vite) e backend (FastAPI).
- **Versionamento:** Utilize o Git de forma eficaz, com mensagens de commit claras e significativas. Crie branches para novas funcionalidades e corre√ß√µes.

## ‚úçÔ∏è C√≥digo e Coment√°rios
- **Coment√°rios:**
    - Comente l√≥gica de neg√≥cios complexa, decis√µes de design n√£o √≥bvias, workarounds e algoritmos intrincados. O foco do coment√°rio deve ser o *PORQU√ä* e n√£o o *O QU√ä* (quando este for √≥bvio pela leitura do c√≥digo).
    - Evite coment√°rios redundantes ou que apenas parafraseiam o c√≥digo.
    - Utilize `// TODO:` ou `# TODO:` para marcar tarefas pendentes, explicando o que precisa ser feito.
- **Documenta√ß√£o (Docstrings/JSDoc):**
    - Para o backend Python (FastAPI), utilize docstrings para todas as fun√ß√µes p√∫blicas, classes e m√≥dulos, explicando seu prop√≥sito, argumentos e o que retornam.
    - Para o frontend TypeScript (React), utilize JSDoc/TSDoc para descrever o prop√≥sito de componentes, hooks customizados e fun√ß√µes complexas, incluindo seus props e tipos.
- **Tipagem:**
    - Utilize TypeScript de forma rigorosa no frontend e type hints em Python no backend para garantir a seguran√ßa de tipo e melhorar a legibilidade e manutenibilidade.
- **Nomenclatura:**
    - Prefira nomes expressivos e descritivos a abrevia√ß√µes obscuras para vari√°veis, fun√ß√µes, classes e arquivos. Siga as conven√ß√µes de cada linguagem (camelCase para TS/JS, snake_case para Python).

## ‚öôÔ∏è Ambientes e Configura√ß√£o
- Desenvolva sempre considerando os diferentes ambientes: **desenvolvimento (dev)**, **testes (test)** e **produ√ß√£o (prod)**.
- Gerencie configura√ß√µes sens√≠veis (chaves de API, credenciais de banco de dados) exclusivamente atrav√©s de vari√°veis de ambiente e arquivos `.env`. Nunca versione arquivos `.env` preenchidos ou dados sens√≠veis diretamente no c√≥digo.
- O arquivo `.env.example` deve ser mantido atualizado com todas as vari√°veis necess√°rias para cada ambiente.

## üõ†Ô∏è Tecnologias Espec√≠ficas do Homeo-AI

### Supabase
- **Migra√ß√µes:** Gerencie migra√ß√µes de esquema do banco de dados Supabase utilizando a CLI do Supabase. Armazene os arquivos de migra√ß√£o no versionamento (ex: `supabase/migrations/`).
- **Seguran√ßa de Dados (RLS):** Implemente e mantenha pol√≠ticas de Row Level Security (RLS) robustas para todas as tabelas sens√≠veis no Supabase. A RLS deve ser a principal camada de controle de acesso aos dados.
- **Intera√ß√£o (Backend):** No backend Python, utilize a biblioteca `supabase-py` de forma segura e otimizada para intera√ß√µes com o banco de dados.
- **Intera√ß√£o (Frontend):** No frontend React, utilize `supabase-js` para autentica√ß√£o, subscri√ß√µes em tempo real e outras intera√ß√µes diretas, encapsulando essa l√≥gica em hooks (`useAuth`, `useSubscription`) ou servi√ßos dedicados.

### FastAPI (Backend Python)
- **Schemas Pydantic:** Defina schemas Pydantic claros e precisos para todas as requisi√ß√µes e respostas da API, garantindo valida√ß√£o de dados e documenta√ß√£o autom√°tica (Swagger UI / ReDoc).
- **Inje√ß√£o de Depend√™ncias:** Utilize o sistema de inje√ß√£o de depend√™ncias do FastAPI (ex: `Depends`) para gerenciar autentica√ß√£o, acesso ao banco de dados e outras l√≥gicas transversais de forma limpa.
- **Estrutura de Endpoints:** Organize os endpoints da API de forma l√≥gica por recurso (ex: `routers/profile.py`, `routers/routes.py`), seguindo a estrutura estabelecida.

### React (Frontend TypeScript)
- **Gerenciamento de Estado:**
    - Utilize React Context para estados globais simples e bem definidos (ex: tema da UI, informa√ß√µes de autentica√ß√£o do usu√°rio).
    - Utilize TanStack Query (React Query) para gerenciar o estado de dados do servidor (fetching, caching, synchronizing, updating).
- **Componentiza√ß√£o:**
    - Crie componentes React pequenos, focados em uma √∫nica responsabilidade e reutiliz√°veis.
    - Utilize hooks customizados para encapsular l√≥gica de estado e efeitos colaterais reutiliz√°veis.
- **Shadcn/UI e Tailwind CSS:** Siga as conven√ß√µes do shadcn/ui para utiliza√ß√£o e customiza√ß√£o de componentes. Utilize Tailwind CSS de forma consistente para estiliza√ß√£o.
- **Vari√°veis de Ambiente:** Gerencie chaves de API do frontend (Mapbox, Supabase URL/anon key) atrav√©s de vari√°veis de ambiente (`VITE_APP_*`).

### Integra√ß√£o com Strava
- **L√≥gica Encapsulada:** A l√≥gica de integra√ß√£o com a API do Strava (autentica√ß√£o OAuth 2.0, requisi√ß√µes, tratamento de erros, rate limiting) deve ser encapsulada em m√≥dulos espec√≠ficos no backend (ex: `services/strava_service.py`).
- **Seguran√ßa de Tokens:** Armazene os tokens de acesso e refresh do Strava de forma segura (ex: criptografados no banco de dados Supabase) e gerencie seu ciclo de vida adequadamente.

### Integra√ß√£o com Mapbox
- **Componentes Dedicados:** Encapsule a l√≥gica de intera√ß√£o com Mapbox GL JS em componentes React ou hooks customizados dedicados para facilitar a reutiliza√ß√£o e manuten√ß√£o no frontend.

## üß™ Testes
- **Backend:** Priorize testes unit√°rios para l√≥gica de neg√≥cios cr√≠tica, fun√ß√µes utilit√°rias e servi√ßos. Considere testes de integra√ß√£o para os endpoints da API FastAPI, cobrindo os principais fluxos de usu√°rio.
- **Frontend:** Escreva testes unit√°rios para hooks customizados complexos e fun√ß√µes utilit√°rias. Considere testes de componentes para os principais elementos da UI e testes E2E (End-to-End) para os fluxos de usu√°rio cr√≠ticos.
- **Cobertura:** Busque uma cobertura de testes razo√°vel que traga confian√ßa nas entregas, focando nas √°reas mais cr√≠ticas e complexas do sistema.

## üõ°Ô∏è Seguran√ßa
- **Valida√ß√£o de Entradas:** Valide todas as entradas do usu√°rio rigorosamente, tanto no frontend (para melhor UX) quanto no backend (como principal barreira de seguran√ßa).
- **Princ√≠pio do Menor Privil√©gio:** Garanta que usu√°rios e sistemas tenham apenas as permiss√µes estritamente necess√°rias para realizar suas fun√ß√µes.
- **OWASP:** Esteja ciente das principais vulnerabilidades web (OWASP Top 10) e adote pr√°ticas para mitig√°-las.
- **Depend√™ncias:** Mantenha as depend√™ncias do projeto (frontend e backend) atualizadas para corrigir vulnerabilidades conhecidas.

## ü§ù Colabora√ß√£o e Versionamento (Git)
- **Branches:** Crie branches separadas para cada nova funcionalidade (`feature/nome-da-feature`), corre√ß√£o (`fix/descricao-do-bug`) ou refatora√ß√£o (`refactor/area-refatorada`).
- **Commits:** Escreva mensagens de commit claras, concisas e no imperativo (ex: "Adiciona funcionalidade de login com Strava", "Corrige bug na listagem de rotas").
- **Pull Requests (PRs):**
    - Descreva o prop√≥sito e as mudan√ßas realizadas no PR.
    - Garanta que o c√≥digo do PR esteja alinhado com estas regras do projeto.
    - Revise PRs de outros membros da equipe de forma construtiva.
- **Merge:** Fa√ßa merge de PRs preferencialmente com squash (se apropriado) para manter um hist√≥rico limpo na branch principal (ex: `main` ou `develop`).

## ü§ñ Regras para Intera√ß√£o com a Intelig√™ncia Artificial (Assistente)

### üí° Geral
- O c√≥digo e as sugest√µes geradas pela IA devem seguir rigorosamente todas as regras deste documento.
- Toda sugest√£o ou c√≥digo gerado pela IA deve ser revisado criticamente por um desenvolvedor humano antes de ser integrado ao projeto.
- Utilize a IA como uma ferramenta para acelerar o desenvolvimento, gerar insights, prototipar e auxiliar na depura√ß√£o, mas a responsabilidade final pelas decis√µes de arquitetura e implementa√ß√£o √© sempre humana.
- Antes de modificar ou apagar arquivos/c√≥digo existente, a IA deve sempre pedir confirma√ß√£o, explicando o impacto da mudan√ßa.
- A IA nunca deve sobrescrever arquivos de configura√ß√£o cr√≠ticos (ex: `.env`, `vite.config.ts`, `tailwind.config.ts`) sem confirma√ß√£o expl√≠cita e uma explica√ß√£o clara das altera√ß√µes.

### üõ†Ô∏è Desenvolvimento e Implementa√ß√£o
- Ao solicitar a implementa√ß√£o de um novo recurso, forne√ßa um contexto claro e, se poss√≠vel, um rascunho da funcionalidade esperada.
- A IA deve dividir implementa√ß√µes complexas em etapas menores e test√°veis.

### üîç Debugging (Modo Depurador)
- Ao encontrar um problema, a IA deve:
    1.  Solicitar informa√ß√µes detalhadas sobre o erro (mensagens, logs, comportamento observado).
    2.  Listar de 3 a 5 poss√≠veis causas raiz do problema.
    3.  Sugerir formas de obter mais informa√ß√µes diagn√≥sticas (ex: logs espec√≠ficos, testes pontuais).
    4.  Propor solu√ß√µes claras e concisas, explicando o racional por tr√°s delas.
    5.  Pedir aprova√ß√£o antes de aplicar corre√ß√µes ou remover logs tempor√°rios.

### üó∫Ô∏è Planejamento (Modo Planejador)
- Para tarefas de planejamento, a IA deve:
    1.  Fazer perguntas esclarecedoras para entender completamente os requisitos (se necess√°rio).
    2.  Mapear as principais altera√ß√µes em arquivos e componentes.
    3.  Elaborar um plano de a√ß√£o passo a passo.
    4.  Pedir aprova√ß√£o do plano antes de iniciar a implementa√ß√£o.
    5.  Ao final de cada etapa significativa, informar o que foi conclu√≠do, o que ser√° feito a seguir e o que ainda resta.

## ‚ú® Qualidade e Manuten√ß√£o Cont√≠nua
- **Refatora√ß√£o:** Refatore proativamente c√≥digo que se tornou complexo, duplicado ou dif√≠cil de manter. Sempre explique o motivo e os benef√≠cios da refatora√ß√£o.
- **D√©bito T√©cnico:** Esteja atento ao ac√∫mulo de d√©bito t√©cnico e planeje iniciativas para reduzi-lo.
- **Revis√£o de C√≥digo:** Participe ativamente das revis√µes de c√≥digo, oferecendo feedback construtivo e ajudando a manter a qualidade do projeto.
- **Melhoria Cont√≠nua:** Esteja aberto a aprender novas pr√°ticas, ferramentas e tecnologias que possam beneficiar o projeto Homeo-AI.

## 1. Padr√µes de C√≥digo Limpo

- **Nomenclatura Consistente**: Use `camelCase` para vari√°veis e fun√ß√µes, `PascalCase` para componentes e tipos, e `snake_case` para respeitar os campos do banco de dados Supabase.
- **Componentes Funcionais**: Utilize sempre React Functional Components com TypeScript.
- **Organiza√ß√£o de Importa√ß√µes**: Agrupe as importa√ß√µes por categorias (React, componentes, hooks, utils, tipos) e ordene alfabeticamente dentro de cada grupo.
- **Coment√°rios Significativos**: Adicione coment√°rios apenas quando necess√°rio para explicar a l√≥gica n√£o-trivial.
- **Componentiza√ß√£o**: Evite componentes com mais de 300 linhas; extraia subcomponentes quando necess√°rio.
- **Tipagem Estrita**: Utilize TypeScript com tipagem rigorosa (evite `any` e `unknown`).
- **Uso de Constantes**: Extraia strings e valores m√°gicos para constantes nomeadas.
- **Design Simples**: Prefira composi√ß√£o a heran√ßa, e fun√ß√µes puras quando poss√≠vel.

```typescript
// ‚úÖ Exemplo de bom c√≥digo
import React, { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Button } from '@/components/ui/button';
import { supabase } from '@/integrations/supabase/client';
import type { Insumo } from '@/integrations/supabase/types';

const ESTOQUE_MINIMO_ALERTA = 10;

const InsumosComponent: React.FC = () => {
  const [filtroTipo, setFiltroTipo] = useState<string | null>(null);
  
  const { data: insumos } = useQuery({
    queryKey: ['insumos', filtroTipo],
    queryFn: async () => {
      const query = supabase.from('insumos').select('*');
      
      if (filtroTipo) {
        query.eq('tipo', filtroTipo);
      }
      
      const { data, error } = await query;
      if (error) throw new Error(error.message);
      return data as Insumo[];
    }
  });
  
  return (
    <div>
      {insumos?.map(insumo => (
        <div key={insumo.id} className={insumo.estoque_atual <= ESTOQUE_MINIMO_ALERTA ? 'text-red-500' : ''}>
          {insumo.nome}
        </div>
      ))}
    </div>
  );
};
```

## 2. Arquitetura do Projeto

### 2.1 Estrutura de Pastas

- **`/src/components`**: Componentes reutiliz√°veis
  - **`/ui`**: Componentes b√°sicos da UI (shadcn)
  - **`/layouts`**: Templates de layout
  - **`/Auth`**: Componentes relacionados √† autentica√ß√£o
- **`/src/pages`**: P√°ginas da aplica√ß√£o, organizadas por funcionalidade
  - **`/admin`**: √Årea administrativa, com subpastas por m√≥dulo
- **`/src/hooks`**: Hooks customizados
- **`/src/integrations`**: C√≥digo para integra√ß√£o com servi√ßos externos
  - **`/supabase`**: Cliente e tipos do Supabase
- **`/src/lib`**: Fun√ß√µes utilit√°rias
- **`/public`**: Arquivos est√°ticos

### 2.2 Padr√µes de Design de Interface

- Seguir o design system implementado com shadcn/ui e Tailwind CSS
- Manter consist√™ncia visual em toda a aplica√ß√£o
- Design responsivo para funcionar em desktop e tablets
- Cores do tema aplicadas conforme a identidade visual
- Feedback visual claro para a√ß√µes do usu√°rio (loading states, toasts, etc.)

## 3. Fluxos de Trabalho e Desenvolvimento

### 3.1 Ciclo de Desenvolvimento

1. **Planejamento**: Definir objetivos claros para cada nova funcionalidade
2. **Desenvolvimento**: Implementar c√≥digo seguindo os padr√µes definidos
3. **Testes**: Verificar o funcionamento em ambientes locais
4. **Revis√£o**: Validar a implementa√ß√£o contra requisitos
5. **Deploy**: Publicar em ambiente de produ√ß√£o

### 3.2 Controle de Vers√£o

- Utilize Git para versionamento do c√≥digo
- Cada feature deve ser desenvolvida em uma branch separada
- Commits devem ser at√¥micos e com mensagens descritivas
- Pull requests devem incluir descri√ß√£o da mudan√ßa e possivelmente screenshots
- Versione altera√ß√µes em banco de dados utilizando migrations (quando aplic√°vel)

### 3.3 Ambientes

- **Desenvolvimento**: Ambiente local para implementa√ß√£o e testes
- **Produ√ß√£o**: Ambiente final para uso dos usu√°rios
- Cada ambiente deve ter seu pr√≥prio projeto Supabase

## 4. Seguran√ßa

- Nunca exponha chaves de API diretamente no c√≥digo
- Utilize a autentica√ß√£o do Supabase para controle de acesso
- Implemente valida√ß√£o de dados em todos os formul√°rios
- Proteja rotas administrativas com verifica√ß√£o de permiss√µes
- Sanitize dados de entrada para evitar inje√ß√£o de SQL ou XSS

## 5. Gest√£o de Estado

- Use React Query para estado do servidor, com configura√ß√µes adequadas de cache
- Estado local via useState ou useReducer conforme necessidade
- Evite prop drilling excessivo - considere contexts para estado global
- Prefira otimiza√ß√µes de performance com useMemo e useCallback

## 6. Performance

- Implemente carregamento com lazy loading quando necess√°rio
- Otimize consultas ao Supabase para retornar apenas os dados necess√°rios
- Utilize indexes apropriados nas tabelas do banco de dados
- Minimize rerenderings utilizando memoiza√ß√£o quando apropriado

## 7. Integra√ß√µes

### 7.1 Supabase

- Utilize o cliente gerado com tipagem para todas as opera√ß√µes
- Prefira RLS (Row Level Security) para garantir seguran√ßa no n√≠vel do banco
- Estruture o schema do banco de dados de forma normalizada
- Mantenha a documenta√ß√£o das tabelas e relacionamentos atualizada

## 8. Testes

- Escreva testes unit√°rios para l√≥gica de neg√≥cio cr√≠tica
- Teste manualmente os fluxos de usu√°rio principais ap√≥s cada mudan√ßa significativa
- Verifique o comportamento em diferentes dispositivos e navegadores

## 9. Documenta√ß√£o

- Mantenha o README atualizado com instru√ß√µes de execu√ß√£o
- Documente decis√µes arquiteturais importantes
- Comente c√≥digo complexo e n√£o √≥bvio
- Mantenha a documenta√ß√£o de API e tipos atualizada

## 10. Considera√ß√µes para Novos Recursos

- Novas funcionalidades devem se integrar com o design system existente
- Mudan√ßas no schema de banco devem ser cuidadosamente planejadas
- Novos componentes devem seguir os mesmos padr√µes dos existentes
- Considere a escalabilidade e manutenibilidade de longo prazo

Estas regras servem como guia para manter a consist√™ncia e qualidade do projeto Homeo-AI ao longo do seu desenvolvimento e evolu√ß√£o.

---

√öltima atualiza√ß√£o: 2023-11-10

